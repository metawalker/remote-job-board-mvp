// Generated by Copilot
'use client'

import { useState, useEffect, useCallback } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useUser } from '@/lib/supabase/hooks'

interface PendingJob {
  id: string
  title: string
  description: string
  location: string
  salary_min: number | null
  salary_max: number | null
  employment_type: string
  remote_type: string
  skills: string[]
  apply_url: string | null
  posted_at: string
  created_at: string
  companies: {
    id: string
    name: string
    website: string | null
    is_verified: boolean
  }
}

interface ScrapingSource {
  id: string
  name: string
  url: string
  enabled: boolean
  description: string
}

interface ScrapingSchedule {
  enabled: boolean
  interval: 'hourly' | 'daily' | 'weekly'
  time: string // HH:mm format
  timezone: string
}

interface ScrapingSettings {
  sources: ScrapingSource[]
  schedule: ScrapingSchedule
  notifications: {
    email: boolean
    slack: boolean
    webhookUrl: string
  }
  limits: {
    maxJobsPerRun: number
    cooldownMinutes: number
  }
}

interface ScrapingResult {
  success: boolean
  summary: {
    totalJobsFound: number
    totalJobsInserted: number
    totalErrors: number
  }
  results: Array<{
    source: string
    jobsFound: number
    jobsInserted: number
    errors: string[]
  }>
  message: string
}

interface AdminHookReturn {
  isAdmin: boolean
  isLoading: boolean
  pendingJobs: PendingJob[]
  pendingJobsLoading: boolean
  scrapingInProgress: boolean
  scrapingSettings: ScrapingSettings | null
  settingsLoading: boolean
  fetchPendingJobs: () => Promise<void>
  approveJob: (jobId: string) => Promise<boolean>
  rejectJob: (jobId: string) => Promise<boolean>
  runScraper: () => Promise<ScrapingResult | null>
  loadScrapingSettings: () => Promise<void>
  saveScrapingSettings: (settings: ScrapingSettings) => Promise<boolean>
  getScrapingStats: () => Promise<Record<string, unknown> | null>
}

export function useAdmin(): AdminHookReturn {
  const { user, loading } = useUser()
  const [isAdmin, setIsAdmin] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [pendingJobs, setPendingJobs] = useState<PendingJob[]>([])
  const [pendingJobsLoading, setPendingJobsLoading] = useState(false)
  const [scrapingInProgress, setScrapingInProgress] = useState(false)
  const [scrapingSettings, setScrapingSettings] = useState<ScrapingSettings | null>(null)
  const [settingsLoading, setSettingsLoading] = useState(false)

  const supabase = createClient()

  // Check if user is admin
  useEffect(() => {
    async function checkAdminStatus() {
      if (loading) return
      
      if (!user) {
        setIsAdmin(false)
        setIsLoading(false)
        return
      }

      try {
        const { data, error } = await supabase
          .from('user_profiles')
          .select('is_admin')
          .eq('user_id', user.id)
          .single()

        if (error) {
          console.error('Error checking admin status:', error)
          setIsAdmin(false)
        } else {
          setIsAdmin(data?.is_admin === true)
        }
      } catch (error) {
        console.error('Admin check error:', error)
        setIsAdmin(false)
      } finally {
        setIsLoading(false)
      }
    }

    checkAdminStatus()
  }, [user, loading, supabase])
  // Fetch pending jobs
  const fetchPendingJobs = useCallback(async () => {
    if (!isAdmin) return

    setPendingJobsLoading(true)
    try {
      const response = await fetch('/api/admin/pending-jobs')
      const data = await response.json()

      if (response.ok && data.success) {
        setPendingJobs(data.jobs)
      } else {
        console.error('Error fetching pending jobs:', data.error)
        setPendingJobs([])
      }
    } catch (error) {
      console.error('Fetch pending jobs error:', error)
      setPendingJobs([])
    } finally {
      setPendingJobsLoading(false)
    }
  }, [isAdmin])
  // Run scraper manually
  const runScraper = useCallback(async (): Promise<ScrapingResult | null> => {
    if (!isAdmin || scrapingInProgress) return null

    setScrapingInProgress(true)
    try {
      const response = await fetch('/api/admin/scrape', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      })

      const data = await response.json()

      if (response.ok && data.success) {
        // Refresh pending jobs after scraping
        await fetchPendingJobs()
        return data
      } else {
        console.error('Error running scraper:', data.error)
        return null
      }
    } catch (error) {
      console.error('Scraper error:', error)
      return null
    } finally {
      setScrapingInProgress(false)
    }
  }, [isAdmin, scrapingInProgress, fetchPendingJobs])
  // Load scraping settings
  const loadScrapingSettings = useCallback(async () => {
    if (!isAdmin) return

    setSettingsLoading(true)
    try {
      const response = await fetch('/api/admin/settings')
      const data = await response.json()

      if (response.ok && data.success) {
        setScrapingSettings(data.settings)
      } else {
        // Set default settings if none exist
        const defaultSettings: ScrapingSettings = {
          sources: [
            {
              id: 'ycombinator',
              name: 'YCombinator Jobs',
              url: 'https://www.ycombinator.com/jobs/search?remote=true',
              enabled: true,
              description: 'Remote jobs from Y Combinator startups'
            },
            {
              id: 'weworkremotely',
              name: 'We Work Remotely',
              url: 'https://weworkremotely.com/remote-jobs',
              enabled: true,
              description: 'Popular remote work job board'
            },
            {
              id: 'google',
              name: 'Google Careers',
              url: 'https://careers.google.com/jobs/results/',
              enabled: true,
              description: 'Google job postings with remote options'
            }
          ],
          schedule: {
            enabled: false,
            interval: 'daily',
            time: '09:00',
            timezone: 'UTC'
          },
          notifications: {
            email: false,
            slack: false,
            webhookUrl: ''
          },
          limits: {
            maxJobsPerRun: 100,
            cooldownMinutes: 60
          }
        }
        setScrapingSettings(defaultSettings)
      }
    } catch (error) {
      console.error('Error loading settings:', error)
    } finally {
      setSettingsLoading(false)
    }
  }, [isAdmin])
  // Save scraping settings
  const saveScrapingSettings = useCallback(async (settings: ScrapingSettings): Promise<boolean> => {
    if (!isAdmin) return false

    try {
      const response = await fetch('/api/admin/settings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ settings })
      })

      const data = await response.json()

      if (response.ok && data.success) {
        setScrapingSettings(settings)
        return true
      } else {
        console.error('Error saving settings:', data.error)
        return false
      }
    } catch (error) {
      console.error('Save settings error:', error)
      return false
    }
  }, [isAdmin])
  // Get scraping statistics
  const getScrapingStats = useCallback(async () => {
    if (!isAdmin) return null

    try {
      const response = await fetch('/api/admin/stats')
      const data = await response.json()

      if (response.ok && data.success) {
        return data.stats
      } else {
        console.error('Error fetching stats:', data.error)
        return null
      }
    } catch (error) {
      console.error('Stats error:', error)
      return null
    }
  }, [isAdmin])
  // Approve a job
  const approveJob = useCallback(async (jobId: string): Promise<boolean> => {
    try {
      const response = await fetch(`/api/jobs/${jobId}/approve`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json'
        }
      })

      const data = await response.json()

      if (response.ok && data.success) {
        // Remove from pending jobs list
        setPendingJobs(prev => prev.filter(job => job.id !== jobId))
        return true
      } else {
        console.error('Error approving job:', data.error)
        return false
      }
    } catch (error) {
      console.error('Approve job error:', error)
      return false
    }
  }, [])
  // Reject/delete a job
  const rejectJob = useCallback(async (jobId: string): Promise<boolean> => {
    try {
      const response = await fetch(`/api/jobs/${jobId}/approve`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        }
      })

      const data = await response.json()

      if (response.ok && data.success) {
        // Remove from pending jobs list
        setPendingJobs(prev => prev.filter(job => job.id !== jobId))
        return true
      } else {
        console.error('Error rejecting job:', data.error)
        return false
      }
    } catch (error) {
      console.error('Reject job error:', error)
      return false
    }
  }, [])

  return {
    isAdmin,
    isLoading,
    pendingJobs,
    pendingJobsLoading,
    scrapingInProgress,
    scrapingSettings,
    settingsLoading,
    fetchPendingJobs,
    approveJob,
    rejectJob,
    runScraper,
    loadScrapingSettings,
    saveScrapingSettings,
    getScrapingStats
  }
}
