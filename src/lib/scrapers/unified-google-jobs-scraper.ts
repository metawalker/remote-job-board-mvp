// Generated by Copilot
import { GoogleJobsScraper } from './google-jobs-scraper'
import { GoogleJobsStructuredScraper } from './google-jobs-structured-scraper'
import type { GoogleJobListing } from './google-jobs-scraper'

export interface GoogleJobsScrapingOptions {
  query?: string
  location?: string
  maxPages?: number
  usePuppeteer?: boolean
  useStructured?: boolean
  maxResults?: number
}

export class UnifiedGoogleJobsScraper {
  private puppeteerScraper: GoogleJobsScraper
  private structuredScraper: GoogleJobsStructuredScraper

  constructor() {
    this.puppeteerScraper = new GoogleJobsScraper()
    this.structuredScraper = new GoogleJobsStructuredScraper()
  }

  /**
   * Scrape Google Jobs using both approaches and merge results
   */
  async scrapeJobs(options: GoogleJobsScrapingOptions = {}): Promise<GoogleJobListing[]> {
    const {
      query = 'remote software developer',
      location = 'United States',
      maxPages = 2,
      usePuppeteer = true,
      useStructured = true,
      maxResults = 50
    } = options

    console.log(`Starting unified Google Jobs scraping: ${query} in ${location}`)
    
    const allJobs: GoogleJobListing[] = []
    const errors: string[] = []

    // Try Puppeteer approach first (more reliable but slower)
    if (usePuppeteer) {
      try {
        console.log('Attempting Puppeteer scraping...')
        const puppeteerJobs = await this.puppeteerScraper.scrapeRemoteJobs(query, location, maxPages)
        allJobs.push(...puppeteerJobs)
        console.log(`Puppeteer scraping found ${puppeteerJobs.length} jobs`)
      } catch (error) {
        const errorMsg = `Puppeteer scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`
        console.error(errorMsg)
        errors.push(errorMsg)
      } finally {
        // Always clean up Puppeteer resources
        try {
          await this.puppeteerScraper.close()
        } catch (cleanupError) {
          console.warn('Error closing Puppeteer:', cleanupError)
        }
      }
    }

    // If Puppeteer failed or didn't get enough results, try structured approach
    if (useStructured && (allJobs.length < maxResults / 2 || !usePuppeteer)) {
      try {
        console.log('Attempting structured scraping...')
        const structuredJobs = await this.structuredScraper.scrapeRemoteJobs(query, location, maxPages)
        
        // Merge and deduplicate
        const existingTitles = new Set(allJobs.map(job => `${job.title}-${job.company}`.toLowerCase()))
        const newJobs = structuredJobs.filter(job => 
          !existingTitles.has(`${job.title}-${job.company}`.toLowerCase())
        )
        
        allJobs.push(...newJobs)
        console.log(`Structured scraping found ${structuredJobs.length} jobs (${newJobs.length} new)`)
      } catch (error) {
        const errorMsg = `Structured scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`
        console.error(errorMsg)
        errors.push(errorMsg)
      }
    }

    // Deduplicate, score, and sort results
    const deduplicatedJobs = this.deduplicateJobs(allJobs)
    const scoredJobs = this.scoreAndSortJobs(deduplicatedJobs)
    const finalJobs = scoredJobs.slice(0, maxResults)

    console.log(`Final result: ${finalJobs.length} unique jobs from ${allJobs.length} total scraped`)
    
    if (errors.length > 0) {
      console.warn('Scraping completed with errors:', errors)
    }

    return finalJobs
  }

  /**
   * Remove duplicate jobs based on title, company, and description similarity
   */
  private deduplicateJobs(jobs: GoogleJobListing[]): GoogleJobListing[] {
    const seen = new Set<string>()
    const unique: GoogleJobListing[] = []

    for (const job of jobs) {
      // Create a key for deduplication
      const key = `${job.title.toLowerCase().trim()}-${job.company.toLowerCase().trim()}`
      
      if (!seen.has(key)) {
        seen.add(key)
        unique.push(job)
      }
    }

    return unique
  }

  /**
   * Score jobs based on quality indicators and sort by score
   */
  private scoreAndSortJobs(jobs: GoogleJobListing[]): GoogleJobListing[] {
    return jobs
      .map(job => ({
        ...job,
        score: this.calculateJobScore(job)
      }))
      .sort((a, b) => (b as any).score - (a as any).score)
      .map(({ score, ...job }) => job) // Remove score from final result
  }

  /**
   * Calculate a quality score for a job (0-100)
   */
  private calculateJobScore(job: GoogleJobListing): number {
    let score = 50 // Base score

    // Title quality
    if (job.title.length > 10 && job.title.length < 100) score += 10
    if (job.title.toLowerCase().includes('senior') || job.title.toLowerCase().includes('lead')) score += 5
    if (job.title.toLowerCase().includes('remote')) score += 10

    // Company quality
    if (job.company.length > 2 && !job.company.toLowerCase().includes('unknown')) score += 10

    // Description quality
    if (job.description.length > 200) score += 10
    if (job.description.length > 500) score += 5

    // Has apply URL (direct application)
    if (job.applyUrl && job.applyUrl.includes('http')) score += 15

    // Has salary information
    if (job.salaryText && job.salaryText.length > 5) score += 10

    // Remote indicators
    const remoteKeywords = ['remote', 'work from home', 'distributed', 'telecommute']
    const textToCheck = `${job.title} ${job.location} ${job.description}`.toLowerCase()
    const remoteMatches = remoteKeywords.filter(keyword => textToCheck.includes(keyword)).length
    score += remoteMatches * 3

    // Skills variety
    if (job.skills && job.skills.length > 0) {
      score += Math.min(job.skills.length * 2, 10)
    }

    // Employment type preference (full-time jobs score higher)
    if (job.employmentType === 'full-time') score += 5

    // Penalize very short descriptions or titles
    if (job.description.length < 50) score -= 10
    if (job.title.length < 5) score -= 15

    return Math.max(0, Math.min(100, score))
  }

  /**
   * Get scraping statistics and health check
   */
  async getScrapingHealth(): Promise<{
    puppeteerAvailable: boolean
    structuredAvailable: boolean
    testResults: {
      puppeteer?: boolean
      structured?: boolean
    }
  }> {
    const health = {
      puppeteerAvailable: false,
      structuredAvailable: false,
      testResults: {} as any
    }

    // Test Puppeteer availability
    try {
      await this.puppeteerScraper.initialize()
      await this.puppeteerScraper.close()
      health.puppeteerAvailable = true
      health.testResults.puppeteer = true
    } catch (error) {
      console.warn('Puppeteer not available:', error)
      health.testResults.puppeteer = false
    }

    // Test structured scraper
    try {
      // Simple test to see if we can make a request
      const testJobs = await this.structuredScraper.scrapeRemoteJobs('test', 'US', 1)
      health.structuredAvailable = true
      health.testResults.structured = true
    } catch (error) {
      console.warn('Structured scraper not available:', error)
      health.testResults.structured = false
    }

    return health
  }

  /**
   * Clean up resources
   */
  async close(): Promise<void> {
    try {
      await this.puppeteerScraper.close()
    } catch (error) {
      console.warn('Error closing Puppeteer scraper:', error)
    }
  }
}

export default UnifiedGoogleJobsScraper
